<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã²ã¨ã¯ããƒˆãƒ¬ã‚«ãƒãƒˆãƒ«</title>
    <style>
        /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒ•ã‚©ãƒ³ãƒˆ */
        @import url('https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap');
        
        :root {
            --player-color: #4a90e2;
            --cpu-color: #e24a4a;
            --ap-color: #f5a623;
            --cp-color: #7ed321;
            --bg-color: #f0f8ff;
            /* vminã‚’ä½¿ç”¨ã—ã¦ç”»é¢ã‚µã‚¤ã‚ºã«é€£å‹•ã•ã›ã‚‹ */
            --card-width: 16vmin;
            --card-height: 22.4vmin;
            --card-hover-scale: 1.1;
            --font-size-base: 1.8vmin;
        }

        body {
            font-family: 'Mochiy Pop One', sans-serif;
            background-image: url('https://placehold.co/1920x1080/6abf69/ffffff?text=Grassy+Field');
            background-size: cover;
            background-position: center;
            color: #333;
            margin: 0;
            padding: 0;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        /* ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒ†ãƒŠ */
        #game-container {
            width: 100%;
            height: 100%;
            /* max-width/heightã‚’å‰Šé™¤ã—ã€ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ */
            aspect-ratio: 3 / 2;
            max-width: 100vw;
            max-height: 100vh;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            border: 8px solid #8B4513;
        }

        /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¨ãƒªã‚¢ */
        .player-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5vmin;
            position: relative;
        }

        #cpu-area {
            transform: rotate(180deg);
        }

        /* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ± */
        .player-info {
            position: absolute;
            left: 2vmin;
            top: 2vmin;
            display: flex;
            gap: 1.5vmin;
            background: rgba(255, 255, 255, 0.9);
            padding: 1vmin 1.5vmin;
            border-radius: 2vmin;
            box-shadow: 0 0.2vmin 0.5vmin rgba(0,0,0,0.1);
            z-index: 10;
        }
        #player-area .player-info {
            top: auto;
            bottom: 2vmin;
        }

        .status-display {
            font-size: calc(var(--font-size-base) * 1.2);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5vmin;
            padding: 0.5vmin 1.5vmin;
            border-radius: 1.5vmin;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .ap { background-color: var(--ap-color); }
        .cp { background-color: var(--cp-color); }

        /* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */
        .field {
            height: var(--card-height);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1vmin;
            margin-top: 5vmin;
            flex-grow: 1;
        }

        #player-area .field {
            margin-top: 0;
            margin-bottom: 5vmin;
        }

        /* æ‰‹æœ­ */
        .hand {
            height: calc(var(--card-height) + 2vmin);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1vmin;
            position: absolute;
            bottom: -2vmin;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
        }
        
        /* ã‚«ãƒ¼ãƒ‰ */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: 1vmin;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0.4vmin 0.8vmin rgba(0,0,0,0.2);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border: 0.3vmin solid white;
        }
        
        .cpu-hand .card {
            background-image: url('./back.png');
        }

        .player-hand .card:hover {
            transform: translateY(-2vmin) scale(var(--card-hover-scale));
            box-shadow: 0 0.8vmin 1.6vmin rgba(0,0,0,0.3);
            z-index: 100;
        }

        .card .card-stats {
            position: absolute;
            bottom: 0.5vmin;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
        }

        .card .stat {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 3vmin;
            height: 3vmin;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--font-size-base) * 0.8);
            font-weight: bold;
            border: 0.2vmin solid white;
        }
        .card .stat.ap { border-color: var(--ap-color); }
        .card .stat.cp { border-color: var(--cp-color); }

        /* ä¸­å¤®ã‚¨ãƒªã‚¢ */
        #center-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1vmin;
            z-index: 5;
        }

        #turn-end-button {
            padding: 1.5vmin 3vmin;
            font-size: var(--font-size-base);
            font-family: 'Mochiy Pop One', sans-serif;
            cursor: pointer;
            border: none;
            border-radius: 2vmin;
            background-color: #ff6347;
            color: white;
            box-shadow: 0 0.5vmin #d94f38;
            transition: all 0.1s;
        }
        #turn-end-button:active {
            transform: translateY(0.3vmin);
            box-shadow: 0 0.2vmin #d94f38;
        }
        #turn-end-button:disabled {
            background-color: #ccc;
            box-shadow: 0 0.5vmin #aaa;
            cursor: not-allowed;
        }
        
        .deck-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5vmin;
            font-size: calc(var(--font-size-base) * 0.9);
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 1vmin;
            border-radius: 1vmin;
        }

        /* ä¾¿åˆ©æ©Ÿèƒ½ãƒœã‚¿ãƒ³ */
        .utility-buttons {
            position: absolute;
            top: 1vmin;
            right: 1vmin;
            display: flex;
            gap: 1vmin;
            z-index: 20;
        }
        .utility-button {
            width: 5vmin;
            height: 5vmin;
            border-radius: 50%;
            background-color: #4682B4;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--font-size-base) * 1.5);
            cursor: pointer;
            box-shadow: 0 0.4vmin 0.8vmin rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .utility-button:hover {
            transform: scale(1.1);
        }
        
        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background-color: var(--bg-color);
            padding: 2vmin;
            border-radius: 2vmin;
            box-shadow: 0 1vmin 3vmin rgba(0,0,0,0.3);
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-buttons {
            margin-top: 2vmin;
            display: flex;
            justify-content: center;
            gap: 1.5vmin;
        }
        .modal-button {
            padding: 1.2vmin 2.5vmin;
            font-size: var(--font-size-base);
            cursor: pointer;
            border: none;
            border-radius: 1.5vmin;
            color: white;
            box-shadow: 0 0.4vmin #aaa;
            transition: all 0.1s;
        }
        .modal-button:active {
            transform: translateY(0.2vmin);
            box-shadow: 0 0.2vmin #aaa;
        }
        .play-button { background-color: #4CAF50; box-shadow: 0 0.4vmin #45a049; }
        .back-button { background-color: #f44336; box-shadow: 0 0.4vmin #da190b; }
        
        #card-detail-modal-image {
            width: 48vmin;
            height: 67.2vmin;
            border-radius: 1.5vmin;
        }
        
        .card-selection-container {
            display: flex;
            gap: 1vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        #skill-selection-modal .skills {
            display: flex;
            flex-direction: column;
            gap: 1vmin;
            margin-top: 1.5vmin;
        }
        .skill-button {
            padding: 1.5vmin;
            border-radius: 1vmin;
            border: 2px solid #ccc;
            background-color: white;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            text-align: left;
        }
        .skill-button:hover {
            background-color: #e0f7fa;
            border-color: #00bcd4;
        }
        .skill-button h4 { margin: 0 0 0.5vmin 0; font-size: calc(var(--font-size-base) * 0.9); }
        .skill-button p { margin: 0; font-size: calc(var(--font-size-base) * 0.8); }

        #history-log {
            text-align: left;
            padding: 1vmin;
            background: #fff;
            border-radius: 0.5vmin;
            height: 30vmin;
            overflow-y: scroll;
            font-size: calc(var(--font-size-base) * 0.8);
        }
        #history-log p { margin: 0.5vmin 0; }

        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        #skill-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0,0,0,0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #skill-animation.visible {
            opacity: 1;
        }
        .skill-animation-content {
            background: linear-gradient(45deg, #ffde59, #ff914d);
            padding: 3vmin;
            border-radius: 2vmin;
            text-align: center;
            transform: scale(0.5);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 0.5vmin solid white;
            color: #333;
        }
        #skill-animation.visible .skill-animation-content {
            transform: scale(1);
        }
        #skill-animation-image {
            width: 15vmin;
            height: 21vmin;
            border-radius: 1vmin;
            margin-bottom: 1.5vmin;
        }
        #skill-animation-name {
            font-size: calc(var(--font-size-base) * 1.5);
            margin: 0;
            font-weight: bold;
        }
        #skill-animation-desc {
            font-size: var(--font-size-base);
            margin-top: 1vmin;
            max-width: 40vmin;
        }

        /* çŠ¶æ…‹ç•°å¸¸è¡¨ç¤º */
        .effects-display {
            position: absolute;
            right: 2vmin;
            top: 2vmin;
            display: flex;
            flex-direction: column;
            gap: 0.5vmin;
            z-index: 10;
        }
        #player-area .effects-display {
            top: auto;
            bottom: 2vmin;
        }
        .effect-badge {
            background-color: rgba(139, 69, 19, 0.8);
            color: white;
            padding: 0.5vmin 1vmin;
            border-radius: 1vmin;
            font-size: calc(var(--font-size-base) * 0.7);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ */
        #game-over-modal .modal-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        #game-over-title { font-size: calc(var(--font-size-base) * 3); }
        #game-over-message { font-size: calc(var(--font-size-base) * 1.5); margin-top: 1vmin; }
        #restart-button {
            margin-top: 2vmin;
            padding: 1.5vmin 4vmin;
            background-color: #f5a623;
            box-shadow: 0 0.4vmin #d28e1a;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- CPUã‚¨ãƒªã‚¢ -->
        <div id="cpu-area" class="player-area">
            <div class="player-info">
                <div id="cpu-ap" class="status-display ap">AP: 0</div>
                <div id="cpu-cp" class="status-display cp">CP: 0</div>
            </div>
            <div id="cpu-effects" class="effects-display"></div>
            <div id="cpu-field" class="field"></div>
            <div id="cpu-hand" class="hand cpu-hand"></div>
        </div>

        <!-- ä¸­å¤®ã‚¨ãƒªã‚¢ -->
        <div id="center-area">
            <div id="turn-indicator"></div>
            <button id="turn-end-button">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
            <div class="deck-display">
                <span>å±±æœ­</span>
                <span id="player-deck-count">36</span>
            </div>
        </div>

        <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¨ãƒªã‚¢ -->
        <div id="player-area" class="player-area">
            <div class="player-info">
                <div id="player-ap" class="status-display ap">AP: 0</div>
                <div id="player-cp" class="status-display cp">CP: 0</div>
            </div>
            <div id="player-effects" class="effects-display"></div>
            <div id="player-field" class="field"></div>
            <div id="player-hand" class="hand player-hand"></div>
        </div>

        <!-- ä¾¿åˆ©æ©Ÿèƒ½ãƒœã‚¿ãƒ³ -->
        <div class="utility-buttons">
            <div id="rules-button" class="utility-button">ï¼Ÿ</div>
            <div id="history-button" class="utility-button">ğŸ“œ</div>
        </div>

        <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ã‚«ãƒ¼ãƒ‰è©³ç´° -->
        <div id="card-detail-modal" class="modal">
            <div class="modal-content">
                <img id="card-detail-modal-image" src="" alt="ã‚«ãƒ¼ãƒ‰ç”»åƒ">
                <div class="modal-buttons">
                    <button id="play-card-button" class="modal-button play-button">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‡ºã™</button>
                    <button class="modal-button back-button" onclick="closeModal('card-detail-modal')">æˆ»ã‚‹</button>
                </div>
            </div>
        </div>
        
        <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ã‚«ãƒ¼ãƒ‰é¸æŠ(æ±ç”¨) -->
        <div id="card-selection-modal" class="modal">
            <div class="modal-content">
                <h3 id="card-selection-title"></h3>
                <div id="card-selection-container" class="card-selection-container"></div>
                <div class="modal-buttons">
                    <button id="card-selection-cancel-button" class="modal-button back-button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                </div>
            </div>
        </div>


        <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ã‚¹ã‚­ãƒ«é¸æŠ -->
        <div id="skill-selection-modal" class="modal">
            <div class="modal-content">
                <h3>ã‚¹ã‚­ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</h3>
                <div class="skills">
                    <button id="skill-1-button" class="skill-button"></button>
                    <button id="skill-2-button" class="skill-button"></button>
                    <button id="no-skill-button" class="skill-button">
                        <h4>ã‚¹ã‚­ãƒ«ã‚’ä½¿ã‚ãªã„</h4>
                        <p>ã‚«ãƒ¼ãƒ‰ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‡ºã—ã¦ã€CPã ã‘ã‚’ç²å¾—ã—ã¾ã™ã€‚</p>
                    </button>
                </div>
                 <div class="modal-buttons">
                    <button class="modal-button back-button" onclick="closeModal('skill-selection-modal'); openModal('card-detail-modal');">æˆ»ã‚‹</button>
                </div>
            </div>
        </div>

        <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ãƒ«ãƒ¼ãƒ«èª¬æ˜ -->
        <div id="rules-modal" class="modal">
            <div class="modal-content">
                <h2>ã‚²ãƒ¼ãƒ ã®ãƒ«ãƒ¼ãƒ«</h2>
                <p>å…ˆã«CP(ã‚³ãƒã‚¯ãƒˆãƒã‚¤ãƒ³ãƒˆ)ã‚’1000ç‚¹é›†ã‚ãŸæ–¹ã®å‹ã¡ï¼</p>
                <ol style="text-align: left; font-size: calc(var(--font-size-base) * 0.9);">
                    <li>è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãŒå§‹ã¾ã£ãŸã‚‰ã€AP(ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒã‚¤ãƒ³ãƒˆ)ãŒ3å¢—ãˆã¦ã€å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã‚ˆã€‚</li>
                    <li>æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã«ã¯ã€ã‚«ãƒ¼ãƒ‰ã®å·¦ä¸‹ã«æ›¸ã‹ã‚ŒãŸAPãŒå¿…è¦ã ã‚ˆã€‚</li>
                    <li>ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã¨ã€å³ä¸‹ã«æ›¸ã‹ã‚ŒãŸCPãŒã‚‚ã‚‰ãˆã‚‹ï¼</li>
                    <li>å¼·åŠ›ãªã‚¹ã‚­ãƒ«ã‚’ä½¿ã£ã¦ã€ã‚²ãƒ¼ãƒ ã‚’æœ‰åˆ©ã«é€²ã‚ã‚ˆã†ï¼</li>
                    <li>APãŒè¶³ã‚Šãªããªã‚‹ã‹ã€ã‚„ã‚‹ã“ã¨ãŒãªããªã£ãŸã‚‰ã€Œã‚¿ãƒ¼ãƒ³çµ‚äº†ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã­ã€‚</li>
                </ol>
                <button class="modal-button back-button" onclick="closeModal('rules-modal')">é–‰ã˜ã‚‹</button>
            </div>
        </div>

        <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: å±¥æ­´ -->
        <div id="history-modal" class="modal">
            <div class="modal-content">
                <h2>ã‚²ãƒ¼ãƒ ã®å±¥æ­´</h2>
                <div id="history-log"></div>
                <button class="modal-button back-button" onclick="closeModal('history-modal')">é–‰ã˜ã‚‹</button>
            </div>
        </div>
        
        <!-- ãƒ¢ãƒ¼ãƒ€ãƒ«: ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ -->
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <h2 id="game-over-title">æ±ºç€ï¼</h2>
                <p id="game-over-message"></p>
                <button id="restart-button" class="modal-button">ã‚‚ã†ä¸€åº¦éŠã¶</button>
            </div>
        </div>

        <!-- ã‚¹ã‚­ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ -->
        <div id="skill-animation">
            <div class="skill-animation-content">
                <img id="skill-animation-image" src="" alt="">
                <h3 id="skill-animation-name"></h3>
                <p id="skill-animation-desc"></p>
            </div>
        </div>
    </div>

    <script>
    const cardData = [ 
        { id: 1, name: 'é«˜ç”°çŸ¥ç´€', title: 'å®®å¸ã«ãªã‚ŠãŸã„ã‚ˆã†ã‹ã„ã¯ã‹ã›', ap: 3, cp: 100, description: 'å¤§å¥½ããªã‚ˆã†ã‹ã„ç‰©èªã§ç”ºã®ã¿ã‚“ãªã‚’ã¤ãªãã€æœªæ¥ã®ãã‘ã‚“ã‹ã‚‰å®ˆã‚‹ã¯ã‹ã›ï¼ã‚†ã‚ã¯ã¿ã‚“ãªãŒé›†ã¾ã‚‹ç¥ç¤¾ã®å®®å¸ï¼ˆãã†ã˜ï¼‰ã«ãªã‚‹ã“ã¨ã ï¼', skills: [{ name: 'é›†ã¾ã‚Œï¼ã¡ã‚“ã˜ã‚…ã®æ£®ãƒ‘ãƒ¯ãƒ¼', description: 'ç¥ç¤¾ã®æ£®ã«ä»²é–“ãŒé›†ã¾ã‚‹ã‚ˆã†ã«ã€ã“ã‚Œã‹ã‚‰3ã‚¿ãƒ¼ãƒ³ã€è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³çµ‚ã‚ã‚Šã«CPãŒ50ãµãˆã‚‹ï¼' }, { name: 'ã‚„ã¶ã‚‹ãªï¼ä¸€ç›®å…¥é“ï¼ˆã„ã¡ã‚‚ãã«ã‚…ã†ã©ã†ï¼‰ã®ç´„æŸ', description: 'æ¹–ã®ãƒŒã‚·ã¨ã®ç´„æŸã‚’ã‚„ã¶ã£ãŸã‚ˆã†ã«ã€ç›¸æ‰‹ãŒæ¬¡ã®ã‚¿ãƒ¼ãƒ³ã«å¢—ãˆã‚‹APã‚’ï¼‘ã« ã™ã‚‹ï¼' }] }, 
        { id: 2, name: 'è¥¿ä¿£ã¡ã¥å­', title: 'ãŸã¾ã—ã„ã®ãŠã†ãˆã‚“ã ã‚“é•·ã€ã¡ã¥å­ã•ã‚“', ap: 3, cp: 100, description: 'äººã®ã»ã‚“ã—ã¤ã‚’ã¿ã¬ãã€å¿ƒã‹ã‚‰ã®ã€Œå¥½ãã€ã‚’ä¿¡ã˜ã¬ãã“ã¨ã§ã€ã ã‚Œã‚‚ãŒæŒã¤æœ¬æ¥ã®ã‹ãŒã‚„ãã‚’å¼•ãå‡ºã™ã€‚', skills: [{ name: 'ä¸–ç•Œã«ç¾½ã°ãŸããƒã‚¤ãƒ‘ãƒ¼è‹±èªãƒ‘ãƒ¯ãƒ¼', description: 'è‹±èªãƒ‘ãƒ¯ãƒ¼ã§ä¸–ç•Œã¸ã®å†’é™ºãŒå§‹ã¾ã‚‹ï¼æ¬¡ã‹ã‚‰2ã‚¿ãƒ¼ãƒ³ã®é–“ã€æ–°ã—ã„ä»²é–“ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‘¼ã¶ãŸã³ã«ã¤ãªãŒã‚ŠåŠ›ãŒã‚¢ãƒƒãƒ—ã—ã€è¿½åŠ ã§50 CPã‚’ã‚²ãƒƒãƒˆï¼' }, { name: 'ãœã£ãŸã„ã¼ã†ãã‚‡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', description: 'ã€Œã§ãã£ã“ãªã„ã€ã¨ã„ã†è¨€è‘‰ã‚’ãœã£ãŸã„ã¼ã†ãã‚‡ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã¦ã‚“ã‹ã„ã€‚ã“ã“ã‹ã‚‰2ã‚¿ãƒ¼ãƒ³ã®é–“ã€ã‚ãªãŸã®CPã¯ä¸€åˆ‡ã’ã‚“ã—ã‚‡ã†ã—ãªã„ï¼' }] }, 
        { id: 3, name: 'ä¸‰å®…å„ªä½³', title: 'çŸ³ã“ã‚ã‹ã‚‰å§‹ã¾ã£ãŸã‚„ã•ã—ã„ç ”ç©¶å“¡', ap: 4, cp: 80, description: 'çŸ³ã“ã‚ãƒ»åŒ–çŸ³ãƒ»åœ°è³ªã®è¬ã‚’è§£ãæ˜ã‹ã™ã‚„ã•ã—ã„ç ”ç©¶å“¡', skills: [{ name: 'çŸ³ã“ã‚ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°', description: 'çŸ³ã“ã‚ã‹ã‚‰éå»ã‚’èª­ã¿è§£ãã‚ˆã†ã«ã€éå»ã®æˆ¦ç•¥ã‚’å†åˆ©ç”¨ã™ã‚‹ã€‚è‡ªåˆ†ã®å‡ºã—ãŸã‚«ãƒ¼ãƒ‰1æšã‚’é¸ã³ã€ãã®ã‚¹ã‚­ãƒ«åŠ¹æœã‚’1ã¤ç™ºå‹•ã™ã‚‹ã€‚' }, { name: 'ã‚¢ã‚¦ãƒˆãƒ‰ã‚¢ãƒã‚¹ã‚¿ãƒ¼', description: 'ã©ã‚“ãªé€†å¢ƒã§ã‚‚ç”ŸãæŠœãã‚µãƒã‚¤ãƒãƒ«èƒ½åŠ›ã§ã€çª®åœ°ã‹ã‚‰å½¢å‹¢ã‚’ç«‹ã¦ç›´ã™ã€‚è‡ªåˆ†ã®CPãŒç›¸æ‰‹ã‚ˆã‚Šä½ã„å ´åˆã€CPã‚’130ç²å¾—ã™ã‚‹ã€‚' }] }, 
        { id: 4, name: 'å°å·è’¼ä»‹', title: 'ä¸–ç•Œã‚’ç›®æŒ‡ã™ãƒˆãƒã‚µãƒãƒãƒƒã‚¿', ap: 2, cp: 60, description: '6æ­³ã®æ™‚ã‹ã‚‰BMXä¸€ç­‹ã€é«˜æ ¡ã«é€²å­¦ã—ãªã„ã§ãƒ—ãƒ­ã‚’ç›®æŒ‡ã™ã€‚æŠ€ãŒæ±ºã¾ã£ãŸæ™‚ã®å¿«æ„ŸãŒãŸã¾ã‚‰ãªã„', skills: [{ name: 'ã‚¹ãƒ‘ã‚¤ãƒ©ãƒ«ãƒ»ãƒ‰ãƒ©ã‚¤ãƒ–', description: 'BMXã§ã®é€£ç¶šæŠ€ã®ã‚ˆã†ã«ã€APãŒã‚ã‚‹é™ã‚Šã‚³ãƒ³ãƒœã‚’ç¹‹ã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚CPã‚’60ç²å¾—ã™ã‚‹ã€‚APã‚’è¿½åŠ ã§1æ”¯æ‰•ã†ã“ã¨ã§ã€ã“ã®åŠ¹æœã‚’ã‚‚ã†ä¸€åº¦ç™ºå‹•ã™ã‚‹ã€‚' }, { name: 'ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ»ã‚³ãƒã‚¯ãƒˆ', description: 'å½¼ã®ãƒ¦ãƒ¼ãƒ¢ã‚¢ã¯æ•µå‘³æ–¹ã®å£æ ¹ã‚’ãªãã—ã€é–¢ã‚ã‚‹äººã¿ã‚“ãªã«æ–°ãŸãªæ©Ÿä¼šã‚’ä¸ãˆã‚‹ã€‚ãŠäº’ã„ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å±±æœ­ã‹ã‚‰1æšã‚«ãƒ¼ãƒ‰ã‚’å¼•ãã€‚ãã®å¾Œã€ã‚ãªãŸã¯CPã‚’60ç²å¾—ã™ã‚‹ã€‚' }] }, 
        { id: 5, name: 'å±±ä¸‹å…¸é›„', title: 'ãƒãƒ³ã‚¹ãƒˆãƒƒãƒ—æ—…äººã€Œå…ƒç¥–(ãŒã‚“ã)ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼ã€', ap: 3, cp: 80, description: 'ã‹ã‚ã‚„ã‹ãªãƒ•ãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§è‰¯ã„ã˜ã‚‡ã†ã»ã†ã‚’ã‚²ãƒƒãƒˆï¼†ç™ºä¿¡ã™ã‚‹ãƒ‡ã‚¸ã‚¿ãƒ«ãƒˆãƒƒãƒ—ãƒ©ãƒ³ãƒŠãƒ¼', skills: [{ name: 'ã©ã“ã§ã‚‚ãƒˆãƒ©ãƒ™ãƒ«', description: 'èº«è»½ã«ã©ã“ã¸ã§ã‚‚æ—…ã™ã‚‹ã‚ˆã†ã«ã€æ–°ãŸãªã‹ã®ã†ã›ã„ã‚’ãŸãã‚Šã‚ˆã›ã‚‹ã€‚ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‡ºã—ãŸæ™‚ã€è‡ªåˆ†ã®å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1ã¾ã„å¼•ãã€‚' }, { name: 'ï¼“ç‚¹ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«ãƒã‚¤ãƒ³ãƒˆ', description: 'å†™çœŸãƒ»éŸ³æ¥½ãƒ»åœ°ç‚¹ã‚’èåˆã•ã›ã€æ—…ã§å¾—ãŸçŸ¥è¦‹ãŒã¤ãªãŒã‚Šã‚’å¢—å¹…ã—ã€çˆ†ç™ºçš„ãªãƒã‚¤ãƒ³ãƒˆã‚’ç”Ÿã¿å‡ºã™ã€‚ã“ã®ã‚¿ãƒ¼ãƒ³ã€æ¬¡ã«å‡ºã™ã‚«ãƒ¼ãƒ‰ãŒç²å¾—ã™ã‚‹CPã‚’80å¢—åŠ ã•ã›ã‚‹ã€‚' }] }, 
        { id: 6, name: 'å²©å´éº»é‡Œ', title: 'ã“ã©ã‚‚ãŸã¡ã‚’æ”¯ãˆã‚‹ã€ŒãŸã¬ããƒãƒã€', ap: 4, cp: 80, description: 'è¤‡æ•°ã®ãƒœãƒ©ãƒ³ãƒ†ã‚£ã‚¢ã‚’æ˜ã‚‹ãå‰å‘ããªæ€§æ ¼ã§é›£ãªãã“ãªã™ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒãƒã•ã‚“ã€‚', skills: [{ name: 'ãƒãƒ«ãƒãƒ­ãƒ¼ãƒ«é©å¿œåŠ›', description: 'çŠ¶æ³ã«å¿œã˜ã¦å½¹å‰²ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹æŸ”è»Ÿã•ã§ã€ä»²é–“ã®åŠ›ã‚’ã‚‚ã†ä¸€åº¦å¼•ãå‡ºã™ã€‚è‡ªåˆ†ã®ä»–ã®ã‚«ãƒ¼ãƒ‰1æšã‚’é¸ã³ã€ãã®ã‚¹ã‚­ãƒ«ã‚’ã‚‚ã†ä¸€åº¦ç™ºå‹•ã•ã›ã‚‹ã€‚' }, { name: 'ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ‡ã‚¶ã‚¤ãƒ³åŠ›', description: 'å¤šãã®ä»²é–“ã¨ç¹‹ãŒã‚‹ã»ã©ã€ãã®ä¸­å¿ƒã§è¼ãã‚’å¢—ã—å¤§ããªåŠ›ã¨ãªã‚‹ã€‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚ã‚‹è‡ªåˆ†ã®ä»–ã®ã‚«ãƒ¼ãƒ‰æœ€å¤§3æšã¾ã§ã€1æšã«ã¤ãCPã‚’40ç²å¾—ã™ã‚‹ã€‚' }] }, 
        { id: 7, name: 'å±±å†…é–‹äºº', title: 'ã¾ã‚‹ã§é­šï¼ï¼Ÿæµ·ã‚’ã‹ã‘ã‚ãã‚‹ç”·', ap: 4, cp: 120, description: 'äººå‘½æ•‘åŠ©ã®çµŒé¨“ã‹ã‚‰æµ·ã®é­…åŠ›ã«ç›®è¦šã‚ã€ä»Šã¯ãƒ€ã‚¤ãƒ“ãƒ³ã‚°ã¨é‡£ã‚Šã§å…¨å›½ã®æµ·ã‚’å·¡ã‚‹ã€‚ ', skills: [{ name: 'æµ·ç¥ã®å®ˆè­·', description: 'å½¼ãŒå‰µã‚Šå‡ºã™ç©ã‚„ã‹ãªæµ·ã®ã‚ˆã†ãªç©ºé–“ã§ã¯ã€èª°ã‚‚ãŒå®ˆã‚‰ã‚Œå‚·ã¤ã‘ã‚‰ã‚Œã‚‹ã“ã¨ã¯ãªã„ã€‚æ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã¾ã§ã€ã‚ãªãŸã®CPã¯æ¸›å°‘ã—ãªã„ã€‚' }, { name: 'ä¸€æœŸä¸€ä¼šã®é‡£ã‚Šäºº', description: 'å½¼ãŒæ®‹ã—ãŸç¹‹ãŒã‚Šã®è¨˜æ†¶ã¯ã€æ¬¡ã®ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã®é–‹å§‹æ™‚ã«CP80ã¨ãªã£ã¦è¿”ã£ã¦ãã‚‹ã€‚' }] }, 
        { id: 8, name: 'ç”°ä¸­å…¬æ•™', title: 'æœªçŸ¥ã‚’è¿½æ±‚ã™ã‚‹æ¢æ¤œå®¶', ap: 3, cp: 120, description: 'çš†ãŒçŸ¥ã‚‰ãªã„ã“ã¨ã‚’æ¢æ±‚ã—ã€è§£æ˜ã—ã¦ã„ãã“ã¨ãŒå¥½ããªæ¢æ¤œå®¶ã•ã‚“ã€‚', skills: [{ name: 'ã‚¹ãƒ¼ãƒ‘ãƒ¼æ¢æ±‚å¿ƒ', description: 'æœªçŸ¥ã‚’è§£ãæ˜ã‹ã™æ¢æ±‚å¿ƒã§ã€ç›¸æ‰‹ã®æˆ¦ç•¥ã‚’æš´ãã€‚ç›¸æ‰‹ã®æ‰‹æœ­ã‚’å…¨ã¦è¦‹ã‚‹ã€‚' }, { name: 'å–œã³ã®å…±æœ‰', description: 'æ¢æ±‚ã§å¾—ãŸç™ºè¦‹ã®å–œã³ã‚’åˆ†ã¡åˆã†ã“ã¨ã§ã€æ¬¡ãªã‚‹è¡Œå‹•ã¸ã®é¸æŠè‚¢ã‚’åºƒã’ã‚‹ã€‚ã“ã®ã‚«ãƒ¼ãƒ‰ãŒãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‡ºãŸæ™‚ã€å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’2æšå¼•ãã€‚' }] }, 
        { id: 9, name: 'å‰ç”°æ–‡å—£', title: 'ã„ã®ã¡æ´»(ã„)ãç”Ÿãä¼é“å¸«(ã§ã‚“ã©ã†ã—)', ap: 3, cp: 120, description: 'ä»²é–“ã¨å…±ã«ã€ãŠã˜ã„ã¡ã‚ƒã‚“ãŠã°ã‚ã¡ã‚ƒã‚“ãŒãšã£ã¨å…ƒæ°—ã§ã„ã‚‰ã‚Œã‚‹ã‚ˆã†ã€ãŠæ‰‹ä¼ã„ã—ã¦ã„ã‚‹', skills: [{ name: 'ãƒ–ãƒªã‚³ãƒ©ãƒ¼ã‚¸ãƒ¥', description: 'ã€Œä»Šã‚ã‚‹ã‚‚ã®ã‚’çµ„ã¿åˆã‚ã›ã¦å•é¡Œè§£æ±ºã™ã‚‹ã€ãƒ–ãƒªã‚³ãƒ©ãƒ¼ã‚¸ãƒ¥åŠ›ã‚’ç™ºæ®ã—ã€æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰1æšã‚’å±±æœ­ã®ä¸‹ã«æˆ»ã™ã“ã¨ã§ã€APã‚’2ç²å¾—ã™ã‚‹ã€‚' }, { name: 'ã‚‚ã®ã®æœ¬è³ªãƒªã‚µãƒ¼ãƒ', description: 'å•é¡Œã®æœ¬è³ªã‚’è¦‹æŠœãåŠ›ã§ã€ç¤¾ä¼šçš„ãªä»•çµ„ã¿ã‚’ã¤ãªãã€è§£æ±ºã®ç³¸å£ã‚’æ¢ã‚‹ã€‚å±±æœ­ã®ä¸Š3æšã‹ã‚‰æœ€ã‚‚æœ‰åŠ¹ãªã‚«ãƒ¼ãƒ‰1æšã‚’æ‰‹æœ­ã«åŠ ãˆã€æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã¯å±±æœ­ã«æˆ»ã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ã€‚' }] }, 
        { id: 10, name: 'å­å²¡å’Œäºº', title: 'å„ªã—ãå±±ã®æ¢åµ', ap: 4, cp: 80, description: 'å‹•ç‰©ã®å‹•ãã‚’èª­ã¿ã€è¾²å®¶ã•ã‚“ã‚’å›°ã‚‰ã›ã‚‹ç£ã ã‘ã‚’æ•ã¾ãˆã‚‹çŒŸå¸« ã€‚ãã®æ­£ä½“ã¯ã€å‹•ç‰©ã‚’å¿ƒã‹ã‚‰æ„›ã™ã‚‹å„ªã—ãå±±ã®æ¢åµ', skills: [{ name: 'ç—•è·¡è§£æ', description: 'æ¢åµã®çœ¼åŠ›ã§ç›¸æ‰‹ã®æŠ€ã‚’èª­ã¿è§£ãã€‚ç›´å‰ã«ç›¸æ‰‹ãŒä½¿ã£ãŸã‚¹ã‚­ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç™ºå‹•ã™ã‚‹ã€‚' }, { name: 'å¿…ä¸­ã®ç½ ', description: 'ç²ç‰©ãŒé€šã‚‹ä¸€ç‚¹ã‚’è¦‹æŠœãå¿…ä¸­ã®ç½ ã€‚æ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³ã€ç²å¾—ã™ã‚‹å…¨CPã‚’åŠåˆ†ã«ã™ã‚‹ã€‚' }] }, 
        { id: 11, name: 'å²¡å±±å“²ä¹Ÿ', title: 'ã¿ã‚“ãªã‚’å…ƒæ°—ã«ã™ã‚‹ã€ã¦ã¤ãªããƒˆãƒ¬ãƒ¼ãƒŠãƒ¼', ap: 3, cp: 80, description: 'ã²ã¨ã‚Šã²ã¨ã‚Šã®ç›®æ¨™ã‚’è¦‹ã¤ã‘ã€ã¨ãªã‚Šã§æ‰‹ã‚’ã¤ãªãã„ã£ã—ã‚‡ã«æ­©ã‚“ã§ãã‚Œã‚‹ã€‚ã¿ã‚“ãªã‚’å…ƒæ°—ã«ã™ã‚‹è¡—ã®ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼', skills: [{ name: 'ã¦ã¤ãªãä¼´èµ°', description: 'ã€Œã„ã£ã—ã‚‡ã«é€²ã‚‚ã†ã€ãã®ã›ã„ãˆã‚“ãŒåŠ›ã¨ãªã‚Šã€æ¬¡ã‹ã‚‰3ã‚¿ãƒ¼ãƒ³ã®é–“ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‡ºã‚‹å‘³æ–¹ã®ã‹ãã¨ãCPã‚’+20ã™ã‚‹ã€‚' }, { name: 'ã¯ã˜ã‚ã®ä¸€æ­©ï¼', description: 'ã€Œã“ã‚Œãªã‚‰ã§ãã‚‹ã‹ã‚‚ï¼ã€ã¨æ€ã‚ã›ã‚‹æ¥½ã—ã„ãµã‚“ã„ããŒã¡ã‚‡ã†ã›ã‚“ã¸ã®ãƒãƒ¼ãƒ‰ãƒ«ã‚’ãã£ã¨ä¸‹ã’ã‚‹ã€‚ã“ã®ã‚¿ãƒ¼ãƒ³æ¬¡ã«ä½¿ã†ã‚«ãƒ¼ãƒ‰ã®APã‚³ã‚¹ãƒˆã‚’2ä¸‹ã’ã‚‹' }] }, 
        { id: 12, name: 'å²¡ç§€æ¨¹', title: 'äººç¹‹ãã®ãƒ—ãƒ­ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼', ap: 4, cp: 100, description: 'ç‰©äº‹ã‚’æ¥µã‚ã‚‹æ€§æ ¼ã§ã€ç‹¬å‰µçš„ãªç™ºæƒ³ã§äººã‚’ç¹‹ããªãŒã‚‰ä¸–ç•Œã‚’åºƒã’ã¦ã„ãã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼ã€‚', skills: [{ name: 'ç¹‹ãŒã‚Šã®å‰µé€ è€…(ã‚³ãƒã‚¯ãƒˆãƒ»ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼)', description: 'äººã¨äººã‚’ç¹‹ãæ–°ãŸãªé“ã‚’å‰µé€ ã™ã‚‹ã‚ˆã†ã«ã€ä»–ã®ã‚«ãƒ¼ãƒ‰ãŒç¹‹ãŒã‚Šã‚„ã™ããªã‚‹ç’°å¢ƒã‚’ä½œã‚‹ã€‚æ¬¡ã®è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã‹ã‚‰2ã‚¿ãƒ¼ãƒ³ã®é–“ã€è‡ªåˆ†ãŒä½¿ã†ã‚«ãƒ¼ãƒ‰ã®APã‚³ã‚¹ãƒˆã‚’1ä¸‹ã’ã‚‹ã€‚' }, { name: 'ä¸–ç•Œã®ç©¶æ˜è€…(ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ»ã‚µãƒ¼ãƒãƒ£ãƒ¼)', description: 'ç‰©äº‹ã‚’æ¥µã‚ã‚‹æ¢æ±‚å¿ƒã§ã€ç†æƒ³ã®ä¸–ç•Œã‚’å‰µã‚‹ãŸã‚ã®æœ€é©ãªä¸€æšã‚’æ¢ã—å‡ºã™ã€‚å±±æœ­ã‹ã‚‰å¥½ããªã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã³ã€æ‰‹æœ­ã«åŠ ãˆã‚‹ã€‚' }] }, 
        ].map(c => ({...c, imageUrl: `./${String(c.id).padStart(5, '0')}.png` }));
        
    // DOMè¦ç´ ã®å–å¾—
    const D = (id) => document.getElementById(id);
    const playerHandElem = D('player-hand');
    const playerFieldElem = D('player-field');
    const cpuHandElem = D('cpu-hand');
    const cpuFieldElem = D('cpu-field');
    const playerApElem = D('player-ap');
    const playerCpElem = D('player-cp');
    const cpuApElem = D('cpu-ap');
    const cpuCpElem = D('cpu-cp');
    const playerDeckCountElem = D('player-deck-count');
    const turnEndButton = D('turn-end-button');
    const historyLogElem = D('history-log');

    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    let gameState = {};

    // åˆæœŸåŒ–
    function initGame() {
        const baseDeck = [];
        cardData.forEach(card => {
            for (let i = 0; i < 3; i++) {
                baseDeck.push({ ...card, uid: `card-${card.id}-${i}` });
            }
        });

        gameState = {
            player: { deck: shuffle([...baseDeck]), hand: [], field: [], ap: 0, cp: 0, effects: [] },
            cpu: { deck: shuffle([...baseDeck]), hand: [], field: [], ap: 0, cp: 0, effects: [] },
            turn: 'player',
            turnCount: 1,
            selectedCardInfo: null,
            isGameOver: false,
            history: [],
            lastSkillUsedByCPU: null,
            isWaitingForPlayerChoice: false,
        };

        for (let i = 0; i < 3; i++) {
            drawCard('player');
            drawCard('cpu');
        }
        
        logHistory('ã‚²ãƒ¼ãƒ é–‹å§‹ï¼');
        updateAllUI();
        startTurn();
    }
    
    // UIæ›´æ–°ç³»
    function updateAllUI() {
        renderHand(playerHandElem, gameState.player.hand, 'player');
        renderHand(cpuHandElem, gameState.cpu.hand, 'cpu');
        renderField(playerFieldElem, gameState.player.field, 'player');
        renderField(cpuFieldElem, gameState.cpu.field, 'cpu');
        updateStats();
        renderEffects('player');
        renderEffects('cpu');
    }

    function renderHand(element, hand, owner) {
        element.innerHTML = '';
        hand.forEach((card, index) => {
            const cardElem = createCardElement(card);
            cardElem.style.transform = `translateX(${(index - (hand.length - 1) / 2) * 50}px)`;
            if (owner === 'player') {
                cardElem.onclick = () => onCardClick(card, index, 'hand');
            } else {
                cardElem.innerHTML = ''; // CPUã®ã‚«ãƒ¼ãƒ‰æƒ…å ±ã¯éš ã™
            }
            element.appendChild(cardElem);
        });
    }

    function renderField(element, field, owner) {
        element.innerHTML = '';
        field.forEach(card => {
            const cardElem = createCardElement(card);
            cardElem.onclick = () => onCardClick(card, -1, 'field');
            element.appendChild(cardElem);
        });
    }

    function createCardElement(card) {
        const cardElem = document.createElement('div');
        cardElem.className = 'card';
        cardElem.style.backgroundImage = `url(${card.imageUrl})`;
        cardElem.dataset.uid = card.uid;
        cardElem.innerHTML = `
            <div class="card-stats">
                <div class="stat ap">${card.ap}</div>
                <div class="stat cp">${card.cp}</div>
            </div>
        `;
        return cardElem;
    }
    
    function updateStats() {
        playerApElem.textContent = `AP: ${gameState.player.ap}`;
        playerCpElem.textContent = `CP: ${gameState.player.cp}`;
        cpuApElem.textContent = `AP: ${gameState.cpu.ap}`;
        cpuCpElem.textContent = `CP: ${gameState.cpu.cp}`;
        playerDeckCountElem.textContent = gameState.player.deck.length;
    }

    function renderEffects(owner) {
        const playerState = gameState[owner];
        const effectsElem = D(`${owner}-effects`);
        effectsElem.innerHTML = '';
        playerState.effects.forEach(effect => {
            const effectBadge = document.createElement('div');
            effectBadge.className = 'effect-badge';
            effectBadge.textContent = `${effect.name} (ã‚ã¨${effect.duration}T)`;
            effectsElem.appendChild(effectBadge);
        });
    }

    // ã‚«ãƒ¼ãƒ‰æ“ä½œ
    function onCardClick(card, index, context) {
        if (gameState.isWaitingForPlayerChoice || (context === 'hand' && gameState.turn !== 'player') || gameState.isGameOver) return;
        
        gameState.selectedCardInfo = { card, index, context };
        D('card-detail-modal-image').src = card.imageUrl;
        const playButton = D('play-card-button');
        
        if (context === 'hand' && gameState.turn === 'player') {
            playButton.style.display = 'block';
            playButton.onclick = () => {
                if (gameState.player.ap >= card.ap) {
                    openSkillSelectionModal(card);
                } else {
                    alert('APãŒè¶³ã‚Šã¾ã›ã‚“ï¼');
                }
            };
        } else {
            playButton.style.display = 'none';
        }
        openModal('card-detail-modal');
    }

    function playCard(skillIndex) {
        const { card, index } = gameState.selectedCardInfo;
        const playerState = gameState.player;
        
        playerState.ap -= card.ap;
        playerState.hand.splice(index, 1);
        playerState.field.push(card);

        let cpGain = card.cp;
        if (playerState.effects.find(e => e.name === 'ã¦ã¤ãªãä¼´èµ°')) cpGain += 20;
        
        playerState.cp += cpGain;
        logHistory(`ã‚ãªãŸã¯ã€Œ${card.name}ã€ã‚’å‡ºã—ã€${cpGain}CPç²å¾—ã€‚`);

        closeModal('skill-selection-modal');
        
        if (skillIndex !== -1) {
            executeSkill(card, skillIndex, 'player');
        } else {
            updateAllUI();
            checkGameOver();
        }
    }
    
    function drawCard(owner) {
        const playerState = gameState[owner];
        if (playerState.deck.length > 0) {
            playerState.hand.push(playerState.deck.pop());
        } else {
            logHistory(`${owner === 'player' ? 'ã‚ãªãŸ' : 'CPU'}ã®å±±æœ­ãŒãªããªã£ãŸï¼`);
        }
    }

    // ã‚¿ãƒ¼ãƒ³ç®¡ç†
    async function startTurn() {
        const owner = gameState.turn;
        const playerState = gameState[owner];

        logHistory(`--- ${owner === 'player' ? 'ã‚ãªãŸ' : 'CPU'}ã®ã‚¿ãƒ¼ãƒ³ (ã‚¿ãƒ¼ãƒ³${gameState.turnCount}) ---`);

        playerState.ap += 3;
        drawCard(owner);
        processEffects('start');
        updateAllUI();
        
        if (owner === 'player') {
            turnEndButton.disabled = false;
        } else {
            turnEndButton.disabled = true;
            await cpuTurn();
        }
    }
    
    function endTurn() {
        if (gameState.turn !== 'player' || gameState.isGameOver || gameState.isWaitingForPlayerChoice) return;
        
        processEffects('end');
        gameState.turn = 'cpu';
        if (gameState.turn === 'player') gameState.turnCount++;
        
        updateAllUI();
        if(!checkGameOver()) startTurn();
    }
    
    // CPUã®æ€è€ƒ
    async function cpuTurn() {
        await sleep(1000);
        const cpuState = gameState.cpu;
        let playedCard = true;

        while(playedCard) {
            playedCard = false;
            const playableCards = cpuState.hand
                .map((card, index) => ({ card, index }))
                .filter(item => cpuState.ap >= item.card.ap)
                .sort((a, b) => b.card.cp - a.card.cp);

            if (playableCards.length > 0) {
                const { card, index } = playableCards[0];
                const skillIndex = Math.random() < 0.8 ? (Math.random() < 0.5 ? 0 : 1) : -1;
                
                cpuState.ap -= card.ap;
                cpuState.hand.splice(index, 1);
                cpuState.field.push(card);
                
                let cpGain = card.cp;
                if (cpuState.effects.find(e => e.name === 'ã¦ã¤ãªãä¼´èµ°')) cpGain += 20;
                cpuState.cp += cpGain;

                logHistory(`CPUã¯ã€Œ${card.name}ã€ã‚’å‡ºã—ã€${cpGain}CPç²å¾—ã€‚`);
                updateAllUI();
                await sleep(1000);

                if (skillIndex !== -1) {
                    await executeSkill(card, skillIndex, 'cpu');
                    gameState.lastSkillUsedByCPU = {card, skillIndex};
                }

                updateAllUI();
                if (checkGameOver()) return;
                playedCard = true;
                await sleep(1500);
            }
        }
        
        processEffects('end');
        gameState.turn = 'player';
        gameState.turnCount++;
        
        updateAllUI();
        if(!checkGameOver()) startTurn();
    }

    // ã‚¹ã‚­ãƒ«å‡¦ç†
    async function executeSkill(card, skillIndex, owner) {
        const skill = card.skills[skillIndex];
        const user = gameState[owner];
        const opponent = gameState[owner === 'player' ? 'cpu' : 'player'];

        await showSkillAnimation(card, skill);
        logHistory(`${owner === 'player' ? 'ã‚ãªãŸ' : 'CPU'}ãŒã‚¹ã‚­ãƒ«ã€Œ${skill.name}ã€ã‚’ç™ºå‹•ï¼`, skill.description);

        switch(card.id) {
            case 1: // é«˜ç”°çŸ¥ç´€
                if (skillIndex === 0) addEffect(owner, { name: 'ã¡ã‚“ã˜ã‚…ã®æ£®ãƒ‘ãƒ¯ãƒ¼', duration: 3, onTurnEnd: (p) => p.cp += 50 });
                else addEffect(owner === 'player' ? 'cpu' : 'player', { name: 'ä¸€ç›®å…¥é“ã®ç´„æŸ', duration: 1, onTurnStart: (p) => p.ap -= 2 });
                break;
            case 2: // è¥¿ä¿£ã¡ã¥å­
                 if (skillIndex === 0) addEffect(owner, { name: 'ãƒã‚¤ãƒ‘ãƒ¼è‹±èªãƒ‘ãƒ¯ãƒ¼', duration: 2, onCardPlay: (p) => p.cp += 50 });
                 else addEffect(owner, { name: 'ãœã£ãŸã„ã¼ã†ãã‚‡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', duration: 2, preventCpLoss: true });
                break;
            case 3: // ä¸‰å®…å„ªä½³
                if (skillIndex === 0) await handleIshikoroReading(owner);
                else if (user.cp < opponent.cp) user.cp += 130;
                break;
            case 4: // å°å·è’¼ä»‹
                if (skillIndex === 0) user.cp += 60;
                else { drawCard('player'); drawCard('cpu'); user.cp += 60; }
                break;
            case 5: // å±±ä¸‹å…¸é›„
                if (skillIndex === 0) drawCard(owner);
                else addEffect(owner, {name: 'ï¼“ç‚¹ãƒˆãƒ©ã‚¤ã‚¢ãƒ³ã‚°ãƒ«', duration: 1, onCardPlayCPBonus: 80});
                break;
            case 6: // å²©å´éº»é‡Œ
                if (skillIndex === 0) await handleMultiRole(owner, card.uid);
                else user.cp += Math.min(user.field.length - 1, 3) * 40;
                break;
            case 7: // å±±å†…é–‹äºº
                if (skillIndex === 0) addEffect(owner, { name: 'æµ·ç¥ã®å®ˆè­·', duration: 2, preventCpLoss: true });
                else addEffect(owner, { name: 'ä¸€æœŸä¸€ä¼š', duration: 1, onTurnStart: (p) => p.cp += 80 });
                break;
            case 8: // ç”°ä¸­å…¬æ•™
                if (skillIndex === 0) logHistory(`ç›¸æ‰‹ã®æ‰‹æœ­: ${opponent.hand.map(c => c.name).join(', ')}`);
                else { drawCard(owner); drawCard(owner); }
                break;
            case 9: // å‰ç”°æ–‡å—£
                if (skillIndex === 0) await handleBricolage(owner);
                else await handleMonoResearch(owner);
                break;
            case 10: // å­å²¡å’Œäºº
                if (skillIndex === 0) {
                    const lastSkill = owner === 'player' ? gameState.lastSkillUsedByCPU : null;
                    if(lastSkill) {
                       logHistory(`ã€Œ${lastSkill.card.name}ã€ã®ã‚¹ã‚­ãƒ«ã€Œ${lastSkill.card.skills[lastSkill.skillIndex].name}ã€ã‚’ã‚³ãƒ”ãƒ¼ï¼`);
                       await executeSkill(lastSkill.card, lastSkill.skillIndex, owner);
                    } else {
                        logHistory('ã‚³ãƒ”ãƒ¼ã§ãã‚‹ã‚¹ã‚­ãƒ«ãŒãªã‹ã£ãŸ...');
                    }
                } else {
                    addEffect(owner === 'player' ? 'cpu' : 'player', { name: 'å¿…ä¸­ã®ç½ ', duration: 1, onCpGain: (cp) => Math.floor(cp / 2) });
                }
                break;
            case 11: // å²¡å±±å“²ä¹Ÿ
                if (skillIndex === 0) addEffect(owner, { name: 'ã¦ã¤ãªãä¼´èµ°', duration: 3 });
                else addEffect(owner, {name: 'ã¯ã˜ã‚ã®ä¸€æ­©ï¼', duration: 1, onCardPlayAPCost: -2});
                break;
            case 12: // å²¡ç§€æ¨¹
                if (skillIndex === 0) addEffect(owner, { name: 'ç¹‹ãŒã‚Šã®å‰µé€ è€…', duration: 2 });
                else drawCard(owner);
                break;
            default: logHistory(`ã€Œ${card.name}ã€ã®ã‚¹ã‚­ãƒ«ã¯ã¾ã å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚`); break;
        }
        updateAllUI();
        checkGameOver();
    }
    
    // çŠ¶æ…‹ç•°å¸¸ï¼ˆåŠ¹æœï¼‰å‡¦ç†
    function addEffect(targetOwner, effect) {
        gameState[targetOwner].effects.push(effect);
        logHistory(`${targetOwner === 'player' ? 'ã‚ãªãŸ' : 'CPU'}ã«åŠ¹æœã€Œ${effect.name}ã€ãŒä»˜ä¸ã•ã‚ŒãŸï¼`);
        renderEffects(targetOwner);
    }
    
    function processEffects(timing) { // 'start' or 'end'
        const owner = gameState.turn;
        gameState[owner].effects = gameState[owner].effects.filter(effect => {
            if (timing === 'start' && effect.onTurnStart) effect.onTurnStart(gameState[owner]);
            if (timing === 'end' && effect.onTurnEnd) effect.onTurnEnd(gameState[owner]);
            effect.duration--;
            return effect.duration > 0;
        });
    }

    // ã‚²ãƒ¼ãƒ é€²è¡Œ
    function checkGameOver() {
        if (gameState.isGameOver) return true;
        if (gameState.player.cp >= 1000) gameOver('ã‚ãªãŸã®å‹ã¡ï¼');
        else if (gameState.cpu.cp >= 1000) gameOver('ã‚ãªãŸã®è² ã‘...');
        else return false;
        return true;
    }

    function gameOver(message) {
        gameState.isGameOver = true;
        D('game-over-message').textContent = message;
        openModal('game-over-modal');
    }
    
    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function logHistory(message, description = '') {
        gameState.history.push(message);
        const logEntry = document.createElement('p');
        logEntry.innerHTML = message + (description ? `<br><small style="opacity:0.8;">${description}</small>` : '');
        historyLogElem.appendChild(logEntry);
        historyLogElem.scrollTop = historyLogElem.scrollHeight;
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«æ“ä½œ
    function openModal(id) { D(id).classList.add('visible'); }
    function closeModal(id) { D(id).classList.remove('visible'); }
    
    function openSkillSelectionModal(card) {
        closeModal('card-detail-modal');
        D('skill-1-button').innerHTML = `<h4>${card.skills[0].name}</h4><p>${card.skills[0].description}</p>`;
        D('skill-2-button').innerHTML = `<h4>${card.skills[1].name}</h4><p>${card.skills[1].description}</p>`;
        D('skill-1-button').onclick = () => playCard(0);
        D('skill-2-button').onclick = () => playCard(1);
        D('no-skill-button').onclick = () => playCard(-1);
        openModal('skill-selection-modal');
    }
    
    async function showSkillAnimation(card, skill) {
        const animElem = D('skill-animation');
        D('skill-animation-image').src = card.imageUrl;
        D('skill-animation-name').textContent = skill.name;
        D('skill-animation-desc').textContent = skill.description;
        animElem.classList.add('visible');
        await sleep(2500);
        animElem.classList.remove('visible');
        await sleep(300);
    }
    
    // ã‚¹ã‚­ãƒ«ç”¨ã‚«ãƒ¼ãƒ‰é¸æŠ
    function openCardSelectionModal(title, cards, onSelect) {
        return new Promise(resolve => {
            gameState.isWaitingForPlayerChoice = true;
            D('card-selection-title').textContent = title;
            const container = D('card-selection-container');
            container.innerHTML = '';
            cards.forEach(card => {
                const cardElem = createCardElement(card);
                cardElem.onclick = () => {
                    closeModal('card-selection-modal');
                    gameState.isWaitingForPlayerChoice = false;
                    onSelect(card);
                    resolve(card);
                };
                container.appendChild(cardElem);
            });
            D('card-selection-cancel-button').onclick = () => {
                closeModal('card-selection-modal');
                gameState.isWaitingForPlayerChoice = false;
                resolve(null); // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            };
            openModal('card-selection-modal');
        });
    }

    // ã‚¹ã‚­ãƒ«å€‹åˆ¥å‡¦ç†
    async function handleBricolage(owner) {
        if (owner === 'player') {
            const cardToReturn = await openCardSelectionModal('å±±æœ­ã«æˆ»ã™ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„', gameState.player.hand, (selectedCard) => {
                const index = gameState.player.hand.findIndex(c => c.uid === selectedCard.uid);
                if (index > -1) {
                    const [card] = gameState.player.hand.splice(index, 1);
                    gameState.player.deck.unshift(card); // å±±æœ­ã®ä¸‹ã«
                    gameState.player.ap += 2;
                }
            });
        } else { // CPUãƒ­ã‚¸ãƒƒã‚¯
            if (gameState.cpu.hand.length > 0) {
                const cardToReturn = gameState.cpu.hand.sort((a,b) => a.cp - b.cp)[0];
                const index = gameState.cpu.hand.findIndex(c => c.uid === cardToReturn.uid);
                const [card] = gameState.cpu.hand.splice(index, 1);
                gameState.cpu.deck.unshift(card);
                gameState.cpu.ap += 2;
                logHistory(`CPUã¯ãƒ–ãƒªã‚³ãƒ©ãƒ¼ã‚¸ãƒ¥ã§ã€Œ${card.name}ã€ã‚’å±±æœ­ã«æˆ»ã—ã€APã‚’2ç²å¾—ã€‚`);
            }
        }
    }
    
    async function handleMonoResearch(owner) {
        const deck = gameState[owner].deck;
        if(deck.length === 0) return;
        const topCards = deck.splice(deck.length - Math.min(3, deck.length));
        
        if (owner === 'player') {
            const selectedCard = await openCardSelectionModal('æ‰‹æœ­ã«åŠ ãˆã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„', topCards, (card) => {
                gameState.player.hand.push(card);
                const rest = topCards.filter(c => c.uid !== card.uid);
                gameState.player.deck.push(...rest);
                shuffle(gameState.player.deck);
            });
        } else { // CPUãƒ­ã‚¸ãƒƒã‚¯
            topCards.sort((a,b) => b.cp - a.cp);
            const selectedCard = topCards.shift();
            gameState.cpu.hand.push(selectedCard);
            gameState.cpu.deck.push(...topCards);
            shuffle(gameState.cpu.deck);
            logHistory(`CPUã¯ã‚‚ã®ã®æœ¬è³ªãƒªã‚µãƒ¼ãƒã§ã€Œ${selectedCard.name}ã€ã‚’æ‰‹æœ­ã«åŠ ãˆãŸã€‚`);
        }
    }

    async function handleIshikoroReading(owner) {
        const field = gameState[owner].field;
        if(field.length < 1) return;
        
        if(owner === 'player') {
            await openCardSelectionModal('ã‚¹ã‚­ãƒ«ã‚’ä½¿ã†ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„', field, async (card) => {
                // å†åº¦ã‚¹ã‚­ãƒ«é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
                gameState.selectedCardInfo = { card, index: -1, context: 'field' }; // contextã¯é‡è¦ã§ã¯ãªã„
                openSkillSelectionModal(card);
            });
        } else { // CPUãƒ­ã‚¸ãƒƒã‚¯
            const cardToUse = field[Math.floor(Math.random() * field.length)];
            const skillIndex = Math.random() < 0.5 ? 0 : 1;
            logHistory(`CPUã¯çŸ³ã“ã‚ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã€Œ${cardToUse.name}ã€ã‚’é¸æŠã€‚`);
            await executeSkill(cardToUse, skillIndex, 'cpu');
        }
    }

    async function handleMultiRole(owner, currentCardUid) {
        const field = gameState[owner].field.filter(c => c.uid !== currentCardUid);
        if(field.length < 1) return;

        if (owner === 'player') {
             await openCardSelectionModal('ã‚¹ã‚­ãƒ«ã‚’å†åº¦ä½¿ã†ã‚«ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§ãã ã•ã„', field, (card) => {
                 gameState.selectedCardInfo = { card, index: -1, context: 'field' };
                 openSkillSelectionModal(card);
             });
        } else { // CPUãƒ­ã‚¸ãƒƒã‚¯
             const cardToUse = field[Math.floor(Math.random() * field.length)];
             const skillIndex = Math.random() < 0.5 ? 0 : 1;
             logHistory(`CPUã¯ãƒãƒ«ãƒãƒ­ãƒ¼ãƒ«é©å¿œåŠ›ã§ã€Œ${cardToUse.name}ã€ã‚’é¸æŠã€‚`);
             await executeSkill(cardToUse, skillIndex, 'cpu');
        }
    }


    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    turnEndButton.addEventListener('click', endTurn);
    D('rules-button').addEventListener('click', () => openModal('rules-modal'));
    D('history-button').addEventListener('click', () => openModal('history-modal'));
    D('restart-button').addEventListener('click', () => {
        closeModal('game-over-modal');
        initGame();
    });

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    initGame();
    </script>
</body>
</html>

