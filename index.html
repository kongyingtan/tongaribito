<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ひとはくトレカバトル</title>
    <style>
        /* 基本スタイルとフォント */
        @import url('https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&display=swap');
        
        :root {
            --player-color: #4a90e2;
            --cpu-color: #e24a4a;
            --ap-color: #f5a623;
            --cp-color: #7ed321;
            --bg-color: #f0f8ff;
            /* vminを使用して画面サイズに連動させる */
            --card-width: 16vmin;
            --card-height: 22.4vmin;
            --card-hover-scale: 1.1;
            --font-size-base: 1.8vmin;
        }

        body {
            font-family: 'Mochiy Pop One', sans-serif;
            background-image: url('https://placehold.co/1920x1080/6abf69/ffffff?text=Grassy+Field');
            background-size: cover;
            background-position: center;
            color: #333;
            margin: 0;
            padding: 0;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        /* ゲームコンテナ */
        #game-container {
            width: 100%;
            height: 100%;
            /* max-width/heightを削除し、アスペクト比を維持 */
            aspect-ratio: 3 / 2;
            max-width: 100vw;
            max-height: 100vh;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            border: 8px solid #8B4513;
        }

        /* プレイヤーエリア */
        .player-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 1.5vmin;
            position: relative;
        }

        #cpu-area {
            transform: rotate(180deg);
        }

        /* プレイヤー情報 */
        .player-info {
            position: absolute;
            left: 2vmin;
            top: 2vmin;
            display: flex;
            gap: 1.5vmin;
            background: rgba(255, 255, 255, 0.9);
            padding: 1vmin 1.5vmin;
            border-radius: 2vmin;
            box-shadow: 0 0.2vmin 0.5vmin rgba(0,0,0,0.1);
            z-index: 10;
        }
        #player-area .player-info {
            top: auto;
            bottom: 2vmin;
        }

        .status-display {
            font-size: calc(var(--font-size-base) * 1.2);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5vmin;
            padding: 0.5vmin 1.5vmin;
            border-radius: 1.5vmin;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .ap { background-color: var(--ap-color); }
        .cp { background-color: var(--cp-color); }

        /* フィールド */
        .field {
            height: var(--card-height);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1vmin;
            margin-top: 5vmin;
            flex-grow: 1;
        }

        #player-area .field {
            margin-top: 0;
            margin-bottom: 5vmin;
        }

        /* 手札 */
        .hand {
            height: calc(var(--card-height) + 2vmin);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1vmin;
            position: absolute;
            bottom: -2vmin;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
        }
        
        /* カード */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: 1vmin;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0.4vmin 0.8vmin rgba(0,0,0,0.2);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border: 0.3vmin solid white;
        }
        
        .cpu-hand .card {
            background-image: url('./back.png');
        }

        .player-hand .card:hover {
            transform: translateY(-2vmin) scale(var(--card-hover-scale));
            box-shadow: 0 0.8vmin 1.6vmin rgba(0,0,0,0.3);
            z-index: 100;
        }

        .card .card-stats {
            position: absolute;
            bottom: 0.5vmin;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
        }

        .card .stat {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 3vmin;
            height: 3vmin;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--font-size-base) * 0.8);
            font-weight: bold;
            border: 0.2vmin solid white;
        }
        .card .stat.ap { border-color: var(--ap-color); }
        .card .stat.cp { border-color: var(--cp-color); }

        /* 中央エリア */
        #center-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1vmin;
            z-index: 5;
        }

        #turn-end-button {
            padding: 1.5vmin 3vmin;
            font-size: var(--font-size-base);
            font-family: 'Mochiy Pop One', sans-serif;
            cursor: pointer;
            border: none;
            border-radius: 2vmin;
            background-color: #ff6347;
            color: white;
            box-shadow: 0 0.5vmin #d94f38;
            transition: all 0.1s;
        }
        #turn-end-button:active {
            transform: translateY(0.3vmin);
            box-shadow: 0 0.2vmin #d94f38;
        }
        #turn-end-button:disabled {
            background-color: #ccc;
            box-shadow: 0 0.5vmin #aaa;
            cursor: not-allowed;
        }
        
        .deck-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5vmin;
            font-size: calc(var(--font-size-base) * 0.9);
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 1vmin;
            border-radius: 1vmin;
        }

        /* 便利機能ボタン */
        .utility-buttons {
            position: absolute;
            top: 1vmin;
            right: 1vmin;
            display: flex;
            gap: 1vmin;
            z-index: 20;
        }
        .utility-button {
            width: 5vmin;
            height: 5vmin;
            border-radius: 50%;
            background-color: #4682B4;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--font-size-base) * 1.5);
            cursor: pointer;
            box-shadow: 0 0.4vmin 0.8vmin rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        .utility-button:hover {
            transform: scale(1.1);
        }
        
        /* モーダル */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background-color: var(--bg-color);
            padding: 2vmin;
            border-radius: 2vmin;
            box-shadow: 0 1vmin 3vmin rgba(0,0,0,0.3);
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-buttons {
            margin-top: 2vmin;
            display: flex;
            justify-content: center;
            gap: 1.5vmin;
        }
        .modal-button {
            padding: 1.2vmin 2.5vmin;
            font-size: var(--font-size-base);
            cursor: pointer;
            border: none;
            border-radius: 1.5vmin;
            color: white;
            box-shadow: 0 0.4vmin #aaa;
            transition: all 0.1s;
        }
        .modal-button:active {
            transform: translateY(0.2vmin);
            box-shadow: 0 0.2vmin #aaa;
        }
        .play-button { background-color: #4CAF50; box-shadow: 0 0.4vmin #45a049; }
        .back-button { background-color: #f44336; box-shadow: 0 0.4vmin #da190b; }
        
        #card-detail-modal-image {
            width: 48vmin;
            height: 67.2vmin;
            border-radius: 1.5vmin;
        }
        
        .card-selection-container {
            display: flex;
            gap: 1vmin;
            justify-content: center;
            flex-wrap: wrap;
        }

        #skill-selection-modal .skills {
            display: flex;
            flex-direction: column;
            gap: 1vmin;
            margin-top: 1.5vmin;
        }
        .skill-button {
            padding: 1.5vmin;
            border-radius: 1vmin;
            border: 2px solid #ccc;
            background-color: white;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            text-align: left;
        }
        .skill-button:hover {
            background-color: #e0f7fa;
            border-color: #00bcd4;
        }
        .skill-button h4 { margin: 0 0 0.5vmin 0; font-size: calc(var(--font-size-base) * 0.9); }
        .skill-button p { margin: 0; font-size: calc(var(--font-size-base) * 0.8); }

        #history-log {
            text-align: left;
            padding: 1vmin;
            background: #fff;
            border-radius: 0.5vmin;
            height: 30vmin;
            overflow-y: scroll;
            font-size: calc(var(--font-size-base) * 0.8);
        }
        #history-log p { margin: 0.5vmin 0; }

        /* アニメーション */
        #skill-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0,0,0,0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #skill-animation.visible {
            opacity: 1;
        }
        .skill-animation-content {
            background: linear-gradient(45deg, #ffde59, #ff914d);
            padding: 3vmin;
            border-radius: 2vmin;
            text-align: center;
            transform: scale(0.5);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 0.5vmin solid white;
            color: #333;
        }
        #skill-animation.visible .skill-animation-content {
            transform: scale(1);
        }
        #skill-animation-image {
            width: 15vmin;
            height: 21vmin;
            border-radius: 1vmin;
            margin-bottom: 1.5vmin;
        }
        #skill-animation-name {
            font-size: calc(var(--font-size-base) * 1.5);
            margin: 0;
            font-weight: bold;
        }
        #skill-animation-desc {
            font-size: var(--font-size-base);
            margin-top: 1vmin;
            max-width: 40vmin;
        }

        /* 状態異常表示 */
        .effects-display {
            position: absolute;
            right: 2vmin;
            top: 2vmin;
            display: flex;
            flex-direction: column;
            gap: 0.5vmin;
            z-index: 10;
        }
        #player-area .effects-display {
            top: auto;
            bottom: 2vmin;
        }
        .effect-badge {
            background-color: rgba(139, 69, 19, 0.8);
            color: white;
            padding: 0.5vmin 1vmin;
            border-radius: 1vmin;
            font-size: calc(var(--font-size-base) * 0.7);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* ゲームオーバー画面 */
        #game-over-modal .modal-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        #game-over-title { font-size: calc(var(--font-size-base) * 3); }
        #game-over-message { font-size: calc(var(--font-size-base) * 1.5); margin-top: 1vmin; }
        #restart-button {
            margin-top: 2vmin;
            padding: 1.5vmin 4vmin;
            background-color: #f5a623;
            box-shadow: 0 0.4vmin #d28e1a;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- CPUエリア -->
        <div id="cpu-area" class="player-area">
            <div class="player-info">
                <div id="cpu-ap" class="status-display ap">AP: 0</div>
                <div id="cpu-cp" class="status-display cp">CP: 0</div>
            </div>
            <div id="cpu-effects" class="effects-display"></div>
            <div id="cpu-field" class="field"></div>
            <div id="cpu-hand" class="hand cpu-hand"></div>
        </div>

        <!-- 中央エリア -->
        <div id="center-area">
            <div id="turn-indicator"></div>
            <button id="turn-end-button">ターン終了</button>
            <div class="deck-display">
                <span>山札</span>
                <span id="player-deck-count">36</span>
            </div>
        </div>

        <!-- プレイヤーエリア -->
        <div id="player-area" class="player-area">
            <div class="player-info">
                <div id="player-ap" class="status-display ap">AP: 0</div>
                <div id="player-cp" class="status-display cp">CP: 0</div>
            </div>
            <div id="player-effects" class="effects-display"></div>
            <div id="player-field" class="field"></div>
            <div id="player-hand" class="hand player-hand"></div>
        </div>

        <!-- 便利機能ボタン -->
        <div class="utility-buttons">
            <div id="rules-button" class="utility-button">？</div>
            <div id="history-button" class="utility-button">📜</div>
        </div>

        <!-- モーダル: カード詳細 -->
        <div id="card-detail-modal" class="modal">
            <div class="modal-content">
                <img id="card-detail-modal-image" src="" alt="カード画像">
                <div class="modal-buttons">
                    <button id="play-card-button" class="modal-button play-button">フィールドに出す</button>
                    <button class="modal-button back-button" onclick="closeModal('card-detail-modal')">戻る</button>
                </div>
            </div>
        </div>
        
        <!-- モーダル: カード選択(汎用) -->
        <div id="card-selection-modal" class="modal">
            <div class="modal-content">
                <h3 id="card-selection-title"></h3>
                <div id="card-selection-container" class="card-selection-container"></div>
                <div class="modal-buttons">
                    <button id="card-selection-cancel-button" class="modal-button back-button">キャンセル</button>
                </div>
            </div>
        </div>


        <!-- モーダル: スキル選択 -->
        <div id="skill-selection-modal" class="modal">
            <div class="modal-content">
                <h3>スキルを選択してください</h3>
                <div class="skills">
                    <button id="skill-1-button" class="skill-button"></button>
                    <button id="skill-2-button" class="skill-button"></button>
                    <button id="no-skill-button" class="skill-button">
                        <h4>スキルを使わない</h4>
                        <p>カードをフィールドに出して、CPだけを獲得します。</p>
                    </button>
                </div>
                 <div class="modal-buttons">
                    <button class="modal-button back-button" onclick="closeModal('skill-selection-modal'); openModal('card-detail-modal');">戻る</button>
                </div>
            </div>
        </div>

        <!-- モーダル: ルール説明 -->
        <div id="rules-modal" class="modal">
            <div class="modal-content">
                <h2>ゲームのルール</h2>
                <p>先にCP(コネクトポイント)を1000点集めた方の勝ち！</p>
                <ol style="text-align: left; font-size: calc(var(--font-size-base) * 0.9);">
                    <li>自分のターンが始まったら、AP(アクションポイント)が3増えて、山札からカードを1枚引くよ。</li>
                    <li>手札のカードを出すには、カードの左下に書かれたAPが必要だよ。</li>
                    <li>カードを出すと、右下に書かれたCPがもらえる！</li>
                    <li>強力なスキルを使って、ゲームを有利に進めよう！</li>
                    <li>APが足りなくなるか、やることがなくなったら「ターン終了」ボタンを押してね。</li>
                </ol>
                <button class="modal-button back-button" onclick="closeModal('rules-modal')">閉じる</button>
            </div>
        </div>

        <!-- モーダル: 履歴 -->
        <div id="history-modal" class="modal">
            <div class="modal-content">
                <h2>ゲームの履歴</h2>
                <div id="history-log"></div>
                <button class="modal-button back-button" onclick="closeModal('history-modal')">閉じる</button>
            </div>
        </div>
        
        <!-- モーダル: ゲームオーバー -->
        <div id="game-over-modal" class="modal">
            <div class="modal-content">
                <h2 id="game-over-title">決着！</h2>
                <p id="game-over-message"></p>
                <button id="restart-button" class="modal-button">もう一度遊ぶ</button>
            </div>
        </div>

        <!-- スキルアニメーション -->
        <div id="skill-animation">
            <div class="skill-animation-content">
                <img id="skill-animation-image" src="" alt="">
                <h3 id="skill-animation-name"></h3>
                <p id="skill-animation-desc"></p>
            </div>
        </div>
    </div>

    <script>
    const cardData = [ 
        { id: 1, name: '高田知紀', title: '宮司になりたいようかいはかせ', ap: 3, cp: 100, description: '大好きなようかい物語で町のみんなをつなぎ、未来のきけんから守るはかせ！ゆめはみんなが集まる神社の宮司（ぐうじ）になることだ！', skills: [{ name: '集まれ！ちんじゅの森パワー', description: '神社の森に仲間が集まるように、これから3ターン、自分のターン終わりにCPが50ふえる！' }, { name: 'やぶるな！一目入道（いちもくにゅうどう）の約束', description: '湖のヌシとの約束をやぶったように、相手が次のターンに増えるAPを１に する！' }] }, 
        { id: 2, name: '西俣ちづ子', title: 'たましいのおうえんだん長、ちづ子さん', ap: 3, cp: 100, description: '人のほんしつをみぬき、心からの「好き」を信じぬくことで、だれもが持つ本来のかがやきを引き出す。', skills: [{ name: '世界に羽ばたくハイパー英語パワー', description: '英語パワーで世界への冒険が始まる！次から2ターンの間、新しい仲間をフィールドに呼ぶたびにつながり力がアップし、追加で50 CPをゲット！' }, { name: 'ぜったいぼうぎょフィールド', description: '「できっこない」という言葉をぜったいぼうぎょするフィールドをてんかい。ここから2ターンの間、あなたのCPは一切げんしょうしない！' }] }, 
        { id: 3, name: '三宅優佳', title: '石ころから始まったやさしい研究員', ap: 4, cp: 80, description: '石ころ・化石・地質の謎を解き明かすやさしい研究員', skills: [{ name: '石ころリーディング', description: '石ころから過去を読み解くように、過去の戦略を再利用する。自分の出したカード1枚を選び、そのスキル効果を1つ発動する。' }, { name: 'アウトドアマスター', description: 'どんな逆境でも生き抜くサバイバル能力で、窮地から形勢を立て直す。自分のCPが相手より低い場合、CPを130獲得する。' }] }, 
        { id: 4, name: '小川蒼介', title: '世界を目指すトノサマバッタ', ap: 2, cp: 60, description: '6歳の時からBMX一筋、高校に進学しないでプロを目指す。技が決まった時の快感がたまらない', skills: [{ name: 'スパイラル・ドライブ', description: 'BMXでの連続技のように、APがある限りコンボを繋げることができる。CPを60獲得する。APを追加で1支払うことで、この効果をもう一度発動する。' }, { name: 'ワールド・コネクト', description: '彼のユーモアは敵味方の垣根をなくし、関わる人みんなに新たな機会を与える。お互いのプレイヤーは山札から1枚カードを引く。その後、あなたはCPを60獲得する。' }] }, 
        { id: 5, name: '山下典雄', title: 'ノンストップ旅人「元祖(がんそ)インフルエンサー」', ap: 3, cp: 80, description: 'かろやかなフットワークで良いじょうほうをゲット＆発信するデジタルトップランナー', skills: [{ name: 'どこでもトラベル', description: '身軽にどこへでも旅するように、新たなかのうせいをたぐりよせる。このカードをフィールドに出した時、自分の山札からカードを1まい引く。' }, { name: '３点トライアングルポイント', description: '写真・音楽・地点を融合させ、旅で得た知見がつながりを増幅し、爆発的なポイントを生み出す。このターン、次に出すカードが獲得するCPを80増加させる。' }] }, 
        { id: 6, name: '岩崎麻里', title: 'こどもたちを支える「たぬきママ」', ap: 4, cp: 80, description: '複数のボランティアを明るく前向きな性格で難なくこなすスーパーママさん。', skills: [{ name: 'マルチロール適応力', description: '状況に応じて役割を切り替える柔軟さで、仲間の力をもう一度引き出す。自分の他のカード1枚を選び、そのスキルをもう一度発動させる。' }, { name: 'コミュニティデザイン力', description: '多くの仲間と繋がるほど、その中心で輝きを増し大きな力となる。フィールドにある自分の他のカード最大3枚まで、1枚につきCPを40獲得する。' }] }, 
        { id: 7, name: '山内開人', title: 'まるで魚！？海をかけめぐる男', ap: 4, cp: 120, description: '人命救助の経験から海の魅力に目覚め、今はダイビングと釣りで全国の海を巡る。 ', skills: [{ name: '海神の守護', description: '彼が創り出す穏やかな海のような空間では、誰もが守られ傷つけられることはない。次の相手ターン終了時まで、あなたのCPは減少しない。' }, { name: '一期一会の釣り人', description: '彼が残した繋がりの記憶は、次のあなたのターンの開始時にCP80となって返ってくる。' }] }, 
        { id: 8, name: '田中公教', title: '未知を追求する探検家', ap: 3, cp: 120, description: '皆が知らないことを探求し、解明していくことが好きな探検家さん。', skills: [{ name: 'スーパー探求心', description: '未知を解き明かす探求心で、相手の戦略を暴く。相手の手札を全て見る。' }, { name: '喜びの共有', description: '探求で得た発見の喜びを分ち合うことで、次なる行動への選択肢を広げる。このカードがフィールドに出た時、山札からカードを2枚引く。' }] }, 
        { id: 9, name: '前田文嗣', title: 'いのち活(い)き生き伝道師(でんどうし)', ap: 3, cp: 120, description: '仲間と共に、おじいちゃんおばあちゃんがずっと元気でいられるよう、お手伝いしている', skills: [{ name: 'ブリコラージュ', description: '「今あるものを組み合わせて問題解決する」ブリコラージュ力を発揮し、手札のカード1枚を山札の下に戻すことで、APを2獲得する。' }, { name: 'ものの本質リサーチ', description: '問題の本質を見抜く力で、社会的な仕組みをつなぎ、解決の糸口を探る。山札の上3枚から最も有効なカード1枚を手札に加え、残りのカードは山札に戻してシャッフルする。' }] }, 
        { id: 10, name: '孝岡和人', title: '優しき山の探偵', ap: 4, cp: 80, description: '動物の動きを読み、農家さんを困らせる獣だけを捕まえる猟師 。その正体は、動物を心から愛する優しき山の探偵', skills: [{ name: '痕跡解析', description: '探偵の眼力で相手の技を読み解く。直前に相手が使ったスキルをコピーして発動する。' }, { name: '必中の罠', description: '獲物が通る一点を見抜く必中の罠。次の相手ターン、獲得する全CPを半分にする。' }] }, 
        { id: 11, name: '岡山哲也', title: 'みんなを元気にする、てつなぐトレーナー', ap: 3, cp: 80, description: 'ひとりひとりの目標を見つけ、となりで手をつなぎいっしょに歩んでくれる。みんなを元気にする街のトレーナー', skills: [{ name: 'てつなぐ伴走', description: '「いっしょに進もう」そのせいえんが力となり、次から3ターンの間、フィールドに出る味方のかくとくCPを+20する。' }, { name: 'はじめの一歩！', description: '「これならできるかも！」と思わせる楽しいふんいきがちょうせんへのハードルをぐっと下げる。このターン次に使うカードのAPコストを2下げる' }] }, 
        { id: 12, name: '岡秀樹', title: '人繋ぎのプロクリエイター', ap: 4, cp: 100, description: '物事を極める性格で、独創的な発想で人を繋ぎながら世界を広げていくクリエイター。', skills: [{ name: '繋がりの創造者(コネクト・クリエイター)', description: '人と人を繋ぎ新たな道を創造するように、他のカードが繋がりやすくなる環境を作る。次の自分のターンから2ターンの間、自分が使うカードのAPコストを1下げる。' }, { name: '世界の究明者(ワールド・サーチャー)', description: '物事を極める探求心で、理想の世界を創るための最適な一枚を探し出す。山札から好きなカードを1枚選び、手札に加える。' }] }, 
        ].map(c => ({...c, imageUrl: `./${String(c.id).padStart(5, '0')}.png` }));
        
    // DOM要素の取得
    const D = (id) => document.getElementById(id);
    const playerHandElem = D('player-hand');
    const playerFieldElem = D('player-field');
    const cpuHandElem = D('cpu-hand');
    const cpuFieldElem = D('cpu-field');
    const playerApElem = D('player-ap');
    const playerCpElem = D('player-cp');
    const cpuApElem = D('cpu-ap');
    const cpuCpElem = D('cpu-cp');
    const playerDeckCountElem = D('player-deck-count');
    const turnEndButton = D('turn-end-button');
    const historyLogElem = D('history-log');

    // ゲーム状態
    let gameState = {};

    // 初期化
    function initGame() {
        const baseDeck = [];
        cardData.forEach(card => {
            for (let i = 0; i < 3; i++) {
                baseDeck.push({ ...card, uid: `card-${card.id}-${i}` });
            }
        });

        gameState = {
            player: { deck: shuffle([...baseDeck]), hand: [], field: [], ap: 0, cp: 0, effects: [] },
            cpu: { deck: shuffle([...baseDeck]), hand: [], field: [], ap: 0, cp: 0, effects: [] },
            turn: 'player',
            turnCount: 1,
            selectedCardInfo: null,
            isGameOver: false,
            history: [],
            lastSkillUsedByCPU: null,
            isWaitingForPlayerChoice: false,
        };

        for (let i = 0; i < 3; i++) {
            drawCard('player');
            drawCard('cpu');
        }
        
        logHistory('ゲーム開始！');
        updateAllUI();
        startTurn();
    }
    
    // UI更新系
    function updateAllUI() {
        renderHand(playerHandElem, gameState.player.hand, 'player');
        renderHand(cpuHandElem, gameState.cpu.hand, 'cpu');
        renderField(playerFieldElem, gameState.player.field, 'player');
        renderField(cpuFieldElem, gameState.cpu.field, 'cpu');
        updateStats();
        renderEffects('player');
        renderEffects('cpu');
    }

    function renderHand(element, hand, owner) {
        element.innerHTML = '';
        hand.forEach((card, index) => {
            const cardElem = createCardElement(card);
            cardElem.style.transform = `translateX(${(index - (hand.length - 1) / 2) * 50}px)`;
            if (owner === 'player') {
                cardElem.onclick = () => onCardClick(card, index, 'hand');
            } else {
                cardElem.innerHTML = ''; // CPUのカード情報は隠す
            }
            element.appendChild(cardElem);
        });
    }

    function renderField(element, field, owner) {
        element.innerHTML = '';
        field.forEach(card => {
            const cardElem = createCardElement(card);
            cardElem.onclick = () => onCardClick(card, -1, 'field');
            element.appendChild(cardElem);
        });
    }

    function createCardElement(card) {
        const cardElem = document.createElement('div');
        cardElem.className = 'card';
        cardElem.style.backgroundImage = `url(${card.imageUrl})`;
        cardElem.dataset.uid = card.uid;
        cardElem.innerHTML = `
            <div class="card-stats">
                <div class="stat ap">${card.ap}</div>
                <div class="stat cp">${card.cp}</div>
            </div>
        `;
        return cardElem;
    }
    
    function updateStats() {
        playerApElem.textContent = `AP: ${gameState.player.ap}`;
        playerCpElem.textContent = `CP: ${gameState.player.cp}`;
        cpuApElem.textContent = `AP: ${gameState.cpu.ap}`;
        cpuCpElem.textContent = `CP: ${gameState.cpu.cp}`;
        playerDeckCountElem.textContent = gameState.player.deck.length;
    }

    function renderEffects(owner) {
        const playerState = gameState[owner];
        const effectsElem = D(`${owner}-effects`);
        effectsElem.innerHTML = '';
        playerState.effects.forEach(effect => {
            const effectBadge = document.createElement('div');
            effectBadge.className = 'effect-badge';
            effectBadge.textContent = `${effect.name} (あと${effect.duration}T)`;
            effectsElem.appendChild(effectBadge);
        });
    }

    // カード操作
    function onCardClick(card, index, context) {
        if (gameState.isWaitingForPlayerChoice || (context === 'hand' && gameState.turn !== 'player') || gameState.isGameOver) return;
        
        gameState.selectedCardInfo = { card, index, context };
        D('card-detail-modal-image').src = card.imageUrl;
        const playButton = D('play-card-button');
        
        if (context === 'hand' && gameState.turn === 'player') {
            playButton.style.display = 'block';
            playButton.onclick = () => {
                if (gameState.player.ap >= card.ap) {
                    openSkillSelectionModal(card);
                } else {
                    alert('APが足りません！');
                }
            };
        } else {
            playButton.style.display = 'none';
        }
        openModal('card-detail-modal');
    }

    function playCard(skillIndex) {
        const { card, index } = gameState.selectedCardInfo;
        const playerState = gameState.player;
        
        playerState.ap -= card.ap;
        playerState.hand.splice(index, 1);
        playerState.field.push(card);

        let cpGain = card.cp;
        if (playerState.effects.find(e => e.name === 'てつなぐ伴走')) cpGain += 20;
        
        playerState.cp += cpGain;
        logHistory(`あなたは「${card.name}」を出し、${cpGain}CP獲得。`);

        closeModal('skill-selection-modal');
        
        if (skillIndex !== -1) {
            executeSkill(card, skillIndex, 'player');
        } else {
            updateAllUI();
            checkGameOver();
        }
    }
    
    function drawCard(owner) {
        const playerState = gameState[owner];
        if (playerState.deck.length > 0) {
            playerState.hand.push(playerState.deck.pop());
        } else {
            logHistory(`${owner === 'player' ? 'あなた' : 'CPU'}の山札がなくなった！`);
        }
    }

    // ターン管理
    async function startTurn() {
        const owner = gameState.turn;
        const playerState = gameState[owner];

        logHistory(`--- ${owner === 'player' ? 'あなた' : 'CPU'}のターン (ターン${gameState.turnCount}) ---`);

        playerState.ap += 3;
        drawCard(owner);
        processEffects('start');
        updateAllUI();
        
        if (owner === 'player') {
            turnEndButton.disabled = false;
        } else {
            turnEndButton.disabled = true;
            await cpuTurn();
        }
    }
    
    function endTurn() {
        if (gameState.turn !== 'player' || gameState.isGameOver || gameState.isWaitingForPlayerChoice) return;
        
        processEffects('end');
        gameState.turn = 'cpu';
        if (gameState.turn === 'player') gameState.turnCount++;
        
        updateAllUI();
        if(!checkGameOver()) startTurn();
    }
    
    // CPUの思考
    async function cpuTurn() {
        await sleep(1000);
        const cpuState = gameState.cpu;
        let playedCard = true;

        while(playedCard) {
            playedCard = false;
            const playableCards = cpuState.hand
                .map((card, index) => ({ card, index }))
                .filter(item => cpuState.ap >= item.card.ap)
                .sort((a, b) => b.card.cp - a.card.cp);

            if (playableCards.length > 0) {
                const { card, index } = playableCards[0];
                const skillIndex = Math.random() < 0.8 ? (Math.random() < 0.5 ? 0 : 1) : -1;
                
                cpuState.ap -= card.ap;
                cpuState.hand.splice(index, 1);
                cpuState.field.push(card);
                
                let cpGain = card.cp;
                if (cpuState.effects.find(e => e.name === 'てつなぐ伴走')) cpGain += 20;
                cpuState.cp += cpGain;

                logHistory(`CPUは「${card.name}」を出し、${cpGain}CP獲得。`);
                updateAllUI();
                await sleep(1000);

                if (skillIndex !== -1) {
                    await executeSkill(card, skillIndex, 'cpu');
                    gameState.lastSkillUsedByCPU = {card, skillIndex};
                }

                updateAllUI();
                if (checkGameOver()) return;
                playedCard = true;
                await sleep(1500);
            }
        }
        
        processEffects('end');
        gameState.turn = 'player';
        gameState.turnCount++;
        
        updateAllUI();
        if(!checkGameOver()) startTurn();
    }

    // スキル処理
    async function executeSkill(card, skillIndex, owner) {
        const skill = card.skills[skillIndex];
        const user = gameState[owner];
        const opponent = gameState[owner === 'player' ? 'cpu' : 'player'];

        await showSkillAnimation(card, skill);
        logHistory(`${owner === 'player' ? 'あなた' : 'CPU'}がスキル「${skill.name}」を発動！`, skill.description);

        switch(card.id) {
            case 1: // 高田知紀
                if (skillIndex === 0) addEffect(owner, { name: 'ちんじゅの森パワー', duration: 3, onTurnEnd: (p) => p.cp += 50 });
                else addEffect(owner === 'player' ? 'cpu' : 'player', { name: '一目入道の約束', duration: 1, onTurnStart: (p) => p.ap -= 2 });
                break;
            case 2: // 西俣ちづ子
                 if (skillIndex === 0) addEffect(owner, { name: 'ハイパー英語パワー', duration: 2, onCardPlay: (p) => p.cp += 50 });
                 else addEffect(owner, { name: 'ぜったいぼうぎょフィールド', duration: 2, preventCpLoss: true });
                break;
            case 3: // 三宅優佳
                if (skillIndex === 0) await handleIshikoroReading(owner);
                else if (user.cp < opponent.cp) user.cp += 130;
                break;
            case 4: // 小川蒼介
                if (skillIndex === 0) user.cp += 60;
                else { drawCard('player'); drawCard('cpu'); user.cp += 60; }
                break;
            case 5: // 山下典雄
                if (skillIndex === 0) drawCard(owner);
                else addEffect(owner, {name: '３点トライアングル', duration: 1, onCardPlayCPBonus: 80});
                break;
            case 6: // 岩崎麻里
                if (skillIndex === 0) await handleMultiRole(owner, card.uid);
                else user.cp += Math.min(user.field.length - 1, 3) * 40;
                break;
            case 7: // 山内開人
                if (skillIndex === 0) addEffect(owner, { name: '海神の守護', duration: 2, preventCpLoss: true });
                else addEffect(owner, { name: '一期一会', duration: 1, onTurnStart: (p) => p.cp += 80 });
                break;
            case 8: // 田中公教
                if (skillIndex === 0) logHistory(`相手の手札: ${opponent.hand.map(c => c.name).join(', ')}`);
                else { drawCard(owner); drawCard(owner); }
                break;
            case 9: // 前田文嗣
                if (skillIndex === 0) await handleBricolage(owner);
                else await handleMonoResearch(owner);
                break;
            case 10: // 孝岡和人
                if (skillIndex === 0) {
                    const lastSkill = owner === 'player' ? gameState.lastSkillUsedByCPU : null;
                    if(lastSkill) {
                       logHistory(`「${lastSkill.card.name}」のスキル「${lastSkill.card.skills[lastSkill.skillIndex].name}」をコピー！`);
                       await executeSkill(lastSkill.card, lastSkill.skillIndex, owner);
                    } else {
                        logHistory('コピーできるスキルがなかった...');
                    }
                } else {
                    addEffect(owner === 'player' ? 'cpu' : 'player', { name: '必中の罠', duration: 1, onCpGain: (cp) => Math.floor(cp / 2) });
                }
                break;
            case 11: // 岡山哲也
                if (skillIndex === 0) addEffect(owner, { name: 'てつなぐ伴走', duration: 3 });
                else addEffect(owner, {name: 'はじめの一歩！', duration: 1, onCardPlayAPCost: -2});
                break;
            case 12: // 岡秀樹
                if (skillIndex === 0) addEffect(owner, { name: '繋がりの創造者', duration: 2 });
                else drawCard(owner);
                break;
            default: logHistory(`「${card.name}」のスキルはまだ実装されていません。`); break;
        }
        updateAllUI();
        checkGameOver();
    }
    
    // 状態異常（効果）処理
    function addEffect(targetOwner, effect) {
        gameState[targetOwner].effects.push(effect);
        logHistory(`${targetOwner === 'player' ? 'あなた' : 'CPU'}に効果「${effect.name}」が付与された！`);
        renderEffects(targetOwner);
    }
    
    function processEffects(timing) { // 'start' or 'end'
        const owner = gameState.turn;
        gameState[owner].effects = gameState[owner].effects.filter(effect => {
            if (timing === 'start' && effect.onTurnStart) effect.onTurnStart(gameState[owner]);
            if (timing === 'end' && effect.onTurnEnd) effect.onTurnEnd(gameState[owner]);
            effect.duration--;
            return effect.duration > 0;
        });
    }

    // ゲーム進行
    function checkGameOver() {
        if (gameState.isGameOver) return true;
        if (gameState.player.cp >= 1000) gameOver('あなたの勝ち！');
        else if (gameState.cpu.cp >= 1000) gameOver('あなたの負け...');
        else return false;
        return true;
    }

    function gameOver(message) {
        gameState.isGameOver = true;
        D('game-over-message').textContent = message;
        openModal('game-over-modal');
    }
    
    // ユーティリティ
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function logHistory(message, description = '') {
        gameState.history.push(message);
        const logEntry = document.createElement('p');
        logEntry.innerHTML = message + (description ? `<br><small style="opacity:0.8;">${description}</small>` : '');
        historyLogElem.appendChild(logEntry);
        historyLogElem.scrollTop = historyLogElem.scrollHeight;
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // モーダル操作
    function openModal(id) { D(id).classList.add('visible'); }
    function closeModal(id) { D(id).classList.remove('visible'); }
    
    function openSkillSelectionModal(card) {
        closeModal('card-detail-modal');
        D('skill-1-button').innerHTML = `<h4>${card.skills[0].name}</h4><p>${card.skills[0].description}</p>`;
        D('skill-2-button').innerHTML = `<h4>${card.skills[1].name}</h4><p>${card.skills[1].description}</p>`;
        D('skill-1-button').onclick = () => playCard(0);
        D('skill-2-button').onclick = () => playCard(1);
        D('no-skill-button').onclick = () => playCard(-1);
        openModal('skill-selection-modal');
    }
    
    async function showSkillAnimation(card, skill) {
        const animElem = D('skill-animation');
        D('skill-animation-image').src = card.imageUrl;
        D('skill-animation-name').textContent = skill.name;
        D('skill-animation-desc').textContent = skill.description;
        animElem.classList.add('visible');
        await sleep(2500);
        animElem.classList.remove('visible');
        await sleep(300);
    }
    
    // スキル用カード選択
    function openCardSelectionModal(title, cards, onSelect) {
        return new Promise(resolve => {
            gameState.isWaitingForPlayerChoice = true;
            D('card-selection-title').textContent = title;
            const container = D('card-selection-container');
            container.innerHTML = '';
            cards.forEach(card => {
                const cardElem = createCardElement(card);
                cardElem.onclick = () => {
                    closeModal('card-selection-modal');
                    gameState.isWaitingForPlayerChoice = false;
                    onSelect(card);
                    resolve(card);
                };
                container.appendChild(cardElem);
            });
            D('card-selection-cancel-button').onclick = () => {
                closeModal('card-selection-modal');
                gameState.isWaitingForPlayerChoice = false;
                resolve(null); // キャンセル
            };
            openModal('card-selection-modal');
        });
    }

    // スキル個別処理
    async function handleBricolage(owner) {
        if (owner === 'player') {
            const cardToReturn = await openCardSelectionModal('山札に戻すカードを選んでください', gameState.player.hand, (selectedCard) => {
                const index = gameState.player.hand.findIndex(c => c.uid === selectedCard.uid);
                if (index > -1) {
                    const [card] = gameState.player.hand.splice(index, 1);
                    gameState.player.deck.unshift(card); // 山札の下に
                    gameState.player.ap += 2;
                }
            });
        } else { // CPUロジック
            if (gameState.cpu.hand.length > 0) {
                const cardToReturn = gameState.cpu.hand.sort((a,b) => a.cp - b.cp)[0];
                const index = gameState.cpu.hand.findIndex(c => c.uid === cardToReturn.uid);
                const [card] = gameState.cpu.hand.splice(index, 1);
                gameState.cpu.deck.unshift(card);
                gameState.cpu.ap += 2;
                logHistory(`CPUはブリコラージュで「${card.name}」を山札に戻し、APを2獲得。`);
            }
        }
    }
    
    async function handleMonoResearch(owner) {
        const deck = gameState[owner].deck;
        if(deck.length === 0) return;
        const topCards = deck.splice(deck.length - Math.min(3, deck.length));
        
        if (owner === 'player') {
            const selectedCard = await openCardSelectionModal('手札に加えるカードを選んでください', topCards, (card) => {
                gameState.player.hand.push(card);
                const rest = topCards.filter(c => c.uid !== card.uid);
                gameState.player.deck.push(...rest);
                shuffle(gameState.player.deck);
            });
        } else { // CPUロジック
            topCards.sort((a,b) => b.cp - a.cp);
            const selectedCard = topCards.shift();
            gameState.cpu.hand.push(selectedCard);
            gameState.cpu.deck.push(...topCards);
            shuffle(gameState.cpu.deck);
            logHistory(`CPUはものの本質リサーチで「${selectedCard.name}」を手札に加えた。`);
        }
    }

    async function handleIshikoroReading(owner) {
        const field = gameState[owner].field;
        if(field.length < 1) return;
        
        if(owner === 'player') {
            await openCardSelectionModal('スキルを使うカードを選んでください', field, async (card) => {
                // 再度スキル選択モーダルを開く
                gameState.selectedCardInfo = { card, index: -1, context: 'field' }; // contextは重要ではない
                openSkillSelectionModal(card);
            });
        } else { // CPUロジック
            const cardToUse = field[Math.floor(Math.random() * field.length)];
            const skillIndex = Math.random() < 0.5 ? 0 : 1;
            logHistory(`CPUは石ころリーディングで「${cardToUse.name}」を選択。`);
            await executeSkill(cardToUse, skillIndex, 'cpu');
        }
    }

    async function handleMultiRole(owner, currentCardUid) {
        const field = gameState[owner].field.filter(c => c.uid !== currentCardUid);
        if(field.length < 1) return;

        if (owner === 'player') {
             await openCardSelectionModal('スキルを再度使うカードを選んでください', field, (card) => {
                 gameState.selectedCardInfo = { card, index: -1, context: 'field' };
                 openSkillSelectionModal(card);
             });
        } else { // CPUロジック
             const cardToUse = field[Math.floor(Math.random() * field.length)];
             const skillIndex = Math.random() < 0.5 ? 0 : 1;
             logHistory(`CPUはマルチロール適応力で「${cardToUse.name}」を選択。`);
             await executeSkill(cardToUse, skillIndex, 'cpu');
        }
    }


    // イベントリスナー
    turnEndButton.addEventListener('click', endTurn);
    D('rules-button').addEventListener('click', () => openModal('rules-modal'));
    D('history-button').addEventListener('click', () => openModal('history-modal'));
    D('restart-button').addEventListener('click', () => {
        closeModal('game-over-modal');
        initGame();
    });

    // ゲーム開始
    initGame();
    </script>
</body>
</html>

